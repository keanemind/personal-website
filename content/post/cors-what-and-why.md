---
title: "CORS: What and Why"
date: 2023-01-30T03:13:12.271Z
draft: false
---
Even before JavaScript existed, browsers had enabled web developers to create interactive, stateful websites thanks to browser cookies. When a webpage stored a cookie in the browser, the cookie would be automatically attached to subsequent requests to the cookie's origin. Those requests were the result of page navigations by the user or HTML form submissions.

Cookies are often used for authentication; in the process of logging in, a request is made from the browser to the server, and the server sets a cookie when it responds. When the browser makes additional requests to the server later on, which all have the cookie attached, the server uses the presence of the cookie to determine that the user is currently logged in. 

The browser's behavior of automatically attaching cookies based on the destination of the request can be abused by a kind of attack called Cross-Site Request Forgery (CSRF). CSRF attacks are under the broader category of [confused deputy attacks](https://en.wikipedia.org/wiki/Confused_deputy_problem). With CSRF, one site makes requests to another site on behalf of the user and without their consent, analogous to impersonating someone at a bank and withdrawing their money. 

For example, suppose there is a malicious webpage served from shadywebsitedomain.xyz. The page has an HTML form on it, with the action set to Facebook's domain. The page is styled in such a way so as to confuse visitors into clicking the form's submit button. If the user is already logged into Facebook at the time that they click submit, then the browser will have a cookie from facebook.com, and it will attach it to the form's submission request because the request's destination is facebook.com. Since the request has the cookie in it, the Facebook server receiving the request would take an authenticated action on behalf of the user. 

Today, CSRF attacks are prevented by countermeasures such as web servers requiring not only the usual auth cookie, but an additional [CSRF token](https://stackoverflow.com/questions/5207160/what-is-a-csrf-token-what-is-its-importance-and-how-does-it-work) to be included in any important form submission requests. Although CSRF attacks through HTML form elements have been around for a long time, not all web frameworks include CSRF mitigations by default. For example, the [Remix framework](https://remix.run/) boasts its ability to build web pages that work even without JavaScript through liberal use of HTML forms. But if you're using cookies for authentication, you should note that [Remix currently does not come with CSRF protections](https://github.com/remix-run/remix/discussions/2906).

Eventually, JavaScript was added to web browsers, and along with it came the ability to initiate HTTP requests from within JavaScript code. JavaScript made it so that browser users can unwittingly run arbitrary code on their machine by merely visiting a web page. You are probably aware that today, many websites on the internet contain JavaScript code that instructs your browser to do various things you may not want it to be doing, such as tracking you or mining cryptocurrenciesâ€”or perhaps, even attempting a CSRF attack on your bank's website.

Imagine if your browser automatically attached auth cookies to any and all requests made from JavaScript. That would allow anyone to set up a website, say www.nefarious.bad, which contains JavaScript that sends a request to api.yourbank.com to request your account number. Immediately upon visiting that URL, your bank account number would be stolen. That hypothetical CSRF attack would have been trivial to pull off, so the people making web browsers introduced Same-Origin Policy (SOP) to prevent it. 

Same-Origin Policy is a set of rules enforced by the browser that, generally speaking, disallows a page at a given origin A from reading any data loaded from a different origin B. The SOP rules affect various web APIs including DOM access, but I will focus on how they restrict JavaScript-initiated cross-origin requests. A cross-origin request is one in which the webpage  making the request is served from an origin that does not match the request's destination origin. 

As we saw earlier, CSRF attacks were already possible before the introduction of JavaScript; those attacks would be done through GET requests, or POST requests from HTML forms. Browser vendors were unwilling to start blocking cross-origin HTML form posts, since that would break backward compatibility. So even if, hypothetically, SOP prevented JavaScript from making cross-origin POST requests that looked like HTML form requests (`Content-Type: application/x-www-form-urlencoded`), bad actors could still use the HTML form CSRF attack I described earlier to achieve the exact same result. 

Therefore, it was decided that the new SOP rules would not affect the particular kinds of requests that were already possible before JavaScript, and thus already vulnerable to CSRF. Instead, they would restrict the new capabilities brought in by JavaScript in order to avoid introducing any new CSRF attack vectors. Those requests that were possible before JavaScript would be called "simple" requests, and they included most GET requests, most HEAD requests, and the subset of POST requests that can be sent from an HTML form. You can find a more detailed description of "simple" requests on the [MDN page for CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests).

So how would SOP restrict JavaScript requests? As an example, with JavaScript, websites could now make DELETE requests. SOP made it so browsers would refuse to send the DELETE request in the first place if the request was cross-origin. This was the case for all non-"simple" (sometimes called "complex") cross-origin requests. For "simple" requests, the request would be still be sent to the server, but the page would not be allowed to read the response.

Stated succinctly, SOP rules dictated that

1. "Simple" cross-origin requests would be sent to the server, but the page would not be allowed to read the response. 
1. All other cross-origin requests would be blocked from being sent in the first place. 

These restrictions meant that developers building pages which needed to make requests from JavaScript to other origins, such as a single-page application at www.mywebsite.com making an XMLHttpRequest to api.mywebsite.com, would have to use inconvenient workarounds like proxying the latter origin through the former. 

Years later, as single-page applications became more and more popular, browsers added Cross-Origin Resource Sharing (CORS) to address some of those inconveniences. As the name suggests, CORS allows web developers building server endpoints to relax the SOP restrictions on a per-request basis. With CORS, servers could tell web browsers what the JavaScript running on the page would be allowed to do via headers in the response. For the "simple" cross-origin requests, if the server responds using certain headers, then the browser would permit the page's JavaScript to read the response. For all other cross-origin requests, rather than immediately blocking the request, the browser first sends an extra "preflight" request to ask the server if it will allow the original request. If the server responds and gives permission via the headers, the browser will then send the original request and allow the JavaScript to read the response.

Finally, after CORS, the SameSite cookie attribute was added to browsers to tackle some of the same security issues that SOP originally addressed, but by preventing cookies from being attached to requests in the first place, rather than blocking requests entirely.  For two great explanations of how the attribute works, see Rowan Merewood's article [SameSite Cookies Explained](https://web.dev/samesite-cookies-explained/) and Julien Cretel's blog post [The great SameSite confusion](https://jub0bs.com/posts/2021-01-29-great-samesite-confusion/).

I had to piece it together from many different sources, but reading about this history behind CORS has given me a narrative that helps me remember what it actually is and why it exists. If you see anything that needs correcting, please [submit an issue on GitHub](https://github.com/keanemind/personal-website).
